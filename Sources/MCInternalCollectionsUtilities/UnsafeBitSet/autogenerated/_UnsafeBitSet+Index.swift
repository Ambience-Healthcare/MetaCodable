//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Collections open source project
//
// Copyright (c) 2021 - 2024 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

// #############################################################################
// #                                                                           #
// #            DO NOT EDIT THIS FILE; IT IS AUTOGENERATED.                    #
// #                                                                           #
// #############################################################################

// In single module mode, we need these declarations to be internal,
// but in regular builds we want them to be public. Unfortunately
// the current best way to do this is to duplicate all definitions.
#if COLLECTIONS_SINGLE_MODULE
    extension _UnsafeBitSet {
        @frozen @usableFromInline
        struct Index: Comparable, Hashable {
            @usableFromInline
            typealias _Word = _UnsafeBitSet._Word

            @usableFromInline
            var value: UInt

            @inlinable
            init(_ value: UInt) {
                self.value = value
            }

            @inlinable
            init(_ value: Int) {
                self.value = UInt(value)
            }

            @inlinable
            init(word: Int, bit: UInt) {
                assert(word >= 0 && word <= Int.max / _Word.capacity)
                assert(bit < _Word.capacity)
                value = UInt(word &* _Word.capacity) &+ bit
            }
        }
    }

    extension _UnsafeBitSet.Index {
        @inlinable
        var word: Int {
            // Note: We perform on UInts to get faster unsigned math (shifts).
            Int(truncatingIfNeeded: value / UInt(bitPattern: _Word.capacity))
        }

        @inlinable
        var bit: UInt {
            // Note: We perform on UInts to get faster unsigned math (masking).
            value % UInt(bitPattern: _Word.capacity)
        }

        @inlinable
        var split: (word: Int, bit: UInt) {
            (word, bit)
        }

        @inlinable
        var endSplit: (word: Int, bit: UInt) {
            let w = word
            let b = bit
            if w > 0, b == 0 { return (w &- 1, UInt(_Word.capacity)) }
            return (w, b)
        }

        @inlinable
        static func == (left: Self, right: Self) -> Bool {
            left.value == right.value
        }

        @inlinable
        static func < (left: Self, right: Self) -> Bool {
            left.value < right.value
        }

        @inlinable
        func hash(into hasher: inout Hasher) {
            hasher.combine(value)
        }

        @inlinable
        func _successor() -> Self {
            Self(value + 1)
        }

        @inlinable
        func _predecessor() -> Self {
            Self(value - 1)
        }
    }
#else // !COLLECTIONS_SINGLE_MODULE
    public extension _UnsafeBitSet {
        @frozen
        struct Index: Comparable, Hashable {
            @usableFromInline
            typealias _Word = _UnsafeBitSet._Word

            public var value: UInt

            @inlinable
            public init(_ value: UInt) {
                self.value = value
            }

            @inlinable
            public init(_ value: Int) {
                self.value = UInt(value)
            }

            @inlinable
            public init(word: Int, bit: UInt) {
                assert(word >= 0 && word <= Int.max / _Word.capacity)
                assert(bit < _Word.capacity)
                value = UInt(word &* _Word.capacity) &+ bit
            }
        }
    }

    public extension _UnsafeBitSet.Index {
        @inlinable
        var word: Int {
            // Note: We perform on UInts to get faster unsigned math (shifts).
            Int(truncatingIfNeeded: value / UInt(bitPattern: _Word.capacity))
        }

        @inlinable
        var bit: UInt {
            // Note: We perform on UInts to get faster unsigned math (masking).
            value % UInt(bitPattern: _Word.capacity)
        }

        @inlinable
        var split: (word: Int, bit: UInt) {
            (word, bit)
        }

        @inlinable
        var endSplit: (word: Int, bit: UInt) {
            let w = word
            let b = bit
            if w > 0, b == 0 { return (w &- 1, UInt(_Word.capacity)) }
            return (w, b)
        }

        @inlinable
        static func == (left: Self, right: Self) -> Bool {
            left.value == right.value
        }

        @inlinable
        static func < (left: Self, right: Self) -> Bool {
            left.value < right.value
        }

        @inlinable
        func hash(into hasher: inout Hasher) {
            hasher.combine(value)
        }

        @inlinable
        internal func _successor() -> Self {
            Self(value + 1)
        }

        @inlinable
        internal func _predecessor() -> Self {
            Self(value - 1)
        }
    }
#endif // COLLECTIONS_SINGLE_MODULE
