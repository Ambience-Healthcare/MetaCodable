//===----------------------------------------------------------------------===//
//
// This source file is part of the Swift Collections open source project
//
// Copyright (c) 2022 - 2024 Apple Inc. and the Swift project authors
// Licensed under Apache License v2.0 with Runtime Library Exception
//
// See https://swift.org/LICENSE.txt for license information
//
//===----------------------------------------------------------------------===//

// #############################################################################
// #                                                                           #
// #            DO NOT EDIT THIS FILE; IT IS AUTOGENERATED.                    #
// #                                                                           #
// #############################################################################

// In single module mode, we need these declarations to be internal,
// but in regular builds we want them to be public. Unfortunately
// the current best way to do this is to duplicate all definitions.
#if COLLECTIONS_SINGLE_MODULE
    public extension UnsafeMutableBufferPointer {
        @inlinable
        func initialize(fromContentsOf source: Self) -> Index {
            guard source.count > 0 else { return 0 }
            precondition(
                source.count <= count,
                "buffer cannot contain every element from source."
            )
            baseAddress.unsafelyUnwrapped.initialize(
                from: source.baseAddress.unsafelyUnwrapped,
                count: source.count
            )
            return source.count
        }

        @inlinable
        func initialize(fromContentsOf source: Slice<Self>) -> Index {
            let sourceCount = source.count
            guard sourceCount > 0 else { return 0 }
            precondition(
                sourceCount <= count,
                "buffer cannot contain every element from source."
            )
            baseAddress.unsafelyUnwrapped.initialize(
                from: source.base.baseAddress.unsafelyUnwrapped + source.startIndex,
                count: sourceCount
            )
            return sourceCount
        }
    }

    public extension Slice {
        @inlinable @inline(__always)
        func initialize<Element>(
            fromContentsOf source: UnsafeMutableBufferPointer<Element>
        ) -> Index
            where Base == UnsafeMutableBufferPointer<Element>
        {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            let i = target.initialize(fromContentsOf: source)
            return startIndex + i
        }

        @inlinable @inline(__always)
        func initialize<Element>(
            fromContentsOf source: Slice<UnsafeMutableBufferPointer<Element>>
        ) -> Index
            where Base == UnsafeMutableBufferPointer<Element>
        {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            let i = target.initialize(fromContentsOf: source)
            return startIndex + i
        }
    }

    public extension UnsafeMutableBufferPointer {
        @inlinable @inline(__always)
        func initializeAll<C: Collection>(
            fromContentsOf source: C
        ) where C.Element == Element {
            let i = initialize(fromContentsOf: source)
            assert(i == endIndex)
        }

        @inlinable @inline(__always)
        func initializeAll(fromContentsOf source: Self) {
            let i = initialize(fromContentsOf: source)
            assert(i == endIndex)
        }

        @inlinable @inline(__always)
        func initializeAll(fromContentsOf source: Slice<Self>) {
            let i = initialize(fromContentsOf: source)
            assert(i == endIndex)
        }

        @inlinable @inline(__always)
        func moveInitializeAll(fromContentsOf source: Self) {
            let i = moveInitialize(fromContentsOf: source)
            assert(i == endIndex)
        }

        @inlinable @inline(__always)
        func moveInitializeAll(fromContentsOf source: Slice<Self>) {
            let i = moveInitialize(fromContentsOf: source)
            assert(i == endIndex)
        }
    }

    public extension Slice {
        @inlinable @inline(__always)
        func initializeAll<C: Collection>(
            fromContentsOf source: C
        ) where Base == UnsafeMutableBufferPointer<C.Element> {
            let i = initialize(fromContentsOf: source)
            assert(i == endIndex)
        }

        @inlinable @inline(__always)
        func initializeAll<Element>(
            fromContentsOf source: UnsafeMutableBufferPointer<Element>
        ) where Base == UnsafeMutableBufferPointer<Element> {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            target.initializeAll(fromContentsOf: source)
        }

        @inlinable @inline(__always)
        func initializeAll<Element>(
            fromContentsOf source: Slice<UnsafeMutableBufferPointer<Element>>
        ) where Base == UnsafeMutableBufferPointer<Element> {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            target.initializeAll(fromContentsOf: source)
        }

        @inlinable @inline(__always)
        func moveInitializeAll<Element>(
            fromContentsOf source: UnsafeMutableBufferPointer<Element>
        ) where Base == UnsafeMutableBufferPointer<Element> {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            target.moveInitializeAll(fromContentsOf: source)
        }

        @inlinable @inline(__always)
        func moveInitializeAll<Element>(
            fromContentsOf source: Slice<UnsafeMutableBufferPointer<Element>>
        ) where Base == UnsafeMutableBufferPointer<Element> {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            target.moveInitializeAll(fromContentsOf: source)
        }
    }
#else // !COLLECTIONS_SINGLE_MODULE
    public extension UnsafeMutableBufferPointer {
        @inlinable
        func initialize(fromContentsOf source: Self) -> Index {
            guard source.count > 0 else { return 0 }
            precondition(
                source.count <= count,
                "buffer cannot contain every element from source."
            )
            baseAddress.unsafelyUnwrapped.initialize(
                from: source.baseAddress.unsafelyUnwrapped,
                count: source.count
            )
            return source.count
        }

        @inlinable
        func initialize(fromContentsOf source: Slice<Self>) -> Index {
            let sourceCount = source.count
            guard sourceCount > 0 else { return 0 }
            precondition(
                sourceCount <= count,
                "buffer cannot contain every element from source."
            )
            baseAddress.unsafelyUnwrapped.initialize(
                from: source.base.baseAddress.unsafelyUnwrapped + source.startIndex,
                count: sourceCount
            )
            return sourceCount
        }
    }

    public extension Slice {
        @inlinable @inline(__always)
        func initialize<Element>(
            fromContentsOf source: UnsafeMutableBufferPointer<Element>
        ) -> Index
            where Base == UnsafeMutableBufferPointer<Element>
        {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            let i = target.initialize(fromContentsOf: source)
            return startIndex + i
        }

        @inlinable @inline(__always)
        func initialize<Element>(
            fromContentsOf source: Slice<UnsafeMutableBufferPointer<Element>>
        ) -> Index
            where Base == UnsafeMutableBufferPointer<Element>
        {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            let i = target.initialize(fromContentsOf: source)
            return startIndex + i
        }
    }

    public extension UnsafeMutableBufferPointer {
        @inlinable @inline(__always)
        func initializeAll<C: Collection>(
            fromContentsOf source: C
        ) where C.Element == Element {
            let i = initialize(fromContentsOf: source)
            assert(i == endIndex)
        }

        @inlinable @inline(__always)
        func initializeAll(fromContentsOf source: Self) {
            let i = initialize(fromContentsOf: source)
            assert(i == endIndex)
        }

        @inlinable @inline(__always)
        func initializeAll(fromContentsOf source: Slice<Self>) {
            let i = initialize(fromContentsOf: source)
            assert(i == endIndex)
        }

        @inlinable @inline(__always)
        func moveInitializeAll(fromContentsOf source: Self) {
            let i = moveInitialize(fromContentsOf: source)
            assert(i == endIndex)
        }

        @inlinable @inline(__always)
        func moveInitializeAll(fromContentsOf source: Slice<Self>) {
            let i = moveInitialize(fromContentsOf: source)
            assert(i == endIndex)
        }
    }

    public extension Slice {
        @inlinable @inline(__always)
        func initializeAll<C: Collection>(
            fromContentsOf source: C
        ) where Base == UnsafeMutableBufferPointer<C.Element> {
            let i = initialize(fromContentsOf: source)
            assert(i == endIndex)
        }

        @inlinable @inline(__always)
        func initializeAll<Element>(
            fromContentsOf source: UnsafeMutableBufferPointer<Element>
        ) where Base == UnsafeMutableBufferPointer<Element> {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            target.initializeAll(fromContentsOf: source)
        }

        @inlinable @inline(__always)
        func initializeAll<Element>(
            fromContentsOf source: Slice<UnsafeMutableBufferPointer<Element>>
        ) where Base == UnsafeMutableBufferPointer<Element> {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            target.initializeAll(fromContentsOf: source)
        }

        @inlinable @inline(__always)
        func moveInitializeAll<Element>(
            fromContentsOf source: UnsafeMutableBufferPointer<Element>
        ) where Base == UnsafeMutableBufferPointer<Element> {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            target.moveInitializeAll(fromContentsOf: source)
        }

        @inlinable @inline(__always)
        func moveInitializeAll<Element>(
            fromContentsOf source: Slice<UnsafeMutableBufferPointer<Element>>
        ) where Base == UnsafeMutableBufferPointer<Element> {
            let target = UnsafeMutableBufferPointer(rebasing: self)
            target.moveInitializeAll(fromContentsOf: source)
        }
    }
#endif // COLLECTIONS_SINGLE_MODULE
